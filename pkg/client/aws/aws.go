package aws

import (
	"context"
	"encoding/json"
	"strings"
	"sync"
	"time"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/config"
	"github.com/aws/aws-sdk-go-v2/credentials/stscreds"
	"github.com/aws/aws-sdk-go-v2/service/secretsmanager"
	"github.com/aws/aws-sdk-go-v2/service/secretsmanager/types"
	"github.com/aws/aws-sdk-go-v2/service/sts"
	"github.com/jbcom/secretsync/pkg/driver"
	"github.com/jbcom/secretsync/pkg/utils"
	log "github.com/sirupsen/logrus"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

type AwsClient struct {
	Name           string            `yaml:"name,omitempty" json:"name,omitempty"`
	RoleArn        string            `yaml:"roleArn,omitempty" json:"roleArn,omitempty"`
	Region         string            `yaml:"region,omitempty" json:"region,omitempty"`
	EncryptionKey  string            `yaml:"encryptionKey,omitempty" json:"encryptionKey,omitempty"`
	ReplicaRegions []string          `yaml:"replicaRegions,omitempty" json:"replicaRegions,omitempty"`
	Tags           map[string]string `yaml:"tags,omitempty" json:"tags,omitempty"`

	// NoEmptySecrets skips secrets with empty/null values during listing
	// Matches terraform-aws-secretsmanager no_empty_secrets behavior
	NoEmptySecrets bool `yaml:"noEmptySecrets,omitempty" json:"noEmptySecrets,omitempty"`

	// SkipUnchanged enables idempotent writes (skip if value unchanged)
	// Uses JSON-aware comparison for proper equality checking
	SkipUnchanged bool `yaml:"skipUnchanged,omitempty" json:"skipUnchanged,omitempty"`

	// CacheTTL configures how long to cache ListSecrets results (default: 5 minutes)
	// Set to 0 to disable caching
	CacheTTL time.Duration `yaml:"cacheTTL,omitempty" json:"cacheTTL,omitempty"`

	client *secretsmanager.Client `yaml:"-" json:"-"`

	accountSecretArns map[string]string `yaml:"-" json:"-"`

	// Cache fields for ListSecrets optimization
	cachedSecrets []string      `yaml:"-" json:"-"`
	cacheExpiry   time.Time     `yaml:"-" json:"-"`
	cacheMu       sync.RWMutex  `yaml:"-" json:"-"`
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AwsClient) DeepCopyInto(out *AwsClient) {
	*out = *in
	if in.ReplicaRegions != nil {
		in, out := &in.ReplicaRegions, &out.ReplicaRegions
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.Tags != nil {
		in, out := &in.Tags, &out.Tags
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.accountSecretArns != nil {
		in, out := &in.accountSecretArns, &out.accountSecretArns
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.cachedSecrets != nil {
		in, out := &in.cachedSecrets, &out.cachedSecrets
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	// Note: cacheMu is not copied (each instance needs its own mutex)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AwsClient.
func (in *AwsClient) DeepCopy() *AwsClient {
	if in == nil {
		return nil
	}
	out := new(AwsClient)
	in.DeepCopyInto(out)
	return out
}

func (c *AwsClient) Validate() error {
	l := log.WithFields(log.Fields{
		"action": "Validate",
	})
	l.Trace("start")
	if c.Name == "" {
		return driver.ErrPathRequired
	}
	return nil
}

func NewClient(cfg *AwsClient) (*AwsClient, error) {
	l := log.WithFields(log.Fields{
		"action": "NewClient",
	})
	l.Trace("start")
	vc := &AwsClient{}
	jd, err := json.Marshal(cfg)
	if err != nil {
		l.Debugf("error: %v", err)
		return nil, err
	}
	err = json.Unmarshal(jd, &vc)
	if err != nil {
		l.Debugf("error: %v", err)
		return nil, err
	}
	if vc.Region == "" {
		vc.Region = "us-east-1"
	}
	// Set default cache TTL if not configured
	if vc.CacheTTL == 0 {
		vc.CacheTTL = 5 * time.Minute
	}
	l.Debugf("client=%+v", vc)
	l.Trace("end")
	return vc, nil

}

func (c *AwsClient) CreateClient(ctx context.Context) error {
	return c.CreateClientWithEndpoint(ctx, "")
}

// CreateClientWithEndpoint creates a client with an optional custom endpoint (for LocalStack)
func (c *AwsClient) CreateClientWithEndpoint(ctx context.Context, endpoint string) error {
	l := log.WithFields(log.Fields{
		"action":   "CreateClient",
		"endpoint": endpoint,
	})
	l.Trace("start")
	awscfg, err := config.LoadDefaultConfig(ctx)
	if err != nil {
		l.Debugf("error: %v", err)
		return err
	}
	var provider aws.CredentialsProvider
	if c.RoleArn != "" {
		stsclient := sts.NewFromConfig(awscfg)
		provider = stscreds.NewAssumeRoleProvider(stsclient, c.RoleArn)
		awscfg.Credentials = provider
	}

	opts := secretsmanager.Options{
		Region:      c.Region,
		Credentials: awscfg.Credentials,
	}

	// Support custom endpoint for LocalStack/testing
	if endpoint != "" {
		opts.BaseEndpoint = aws.String(endpoint)
	}

	svc := secretsmanager.New(opts)
	c.client = svc
	l.Trace("end")
	return nil
}

func (vc *AwsClient) Meta() map[string]any {
	md := make(map[string]any)
	jd, err := json.Marshal(vc)
	if err != nil {
		return md
	}
	err = json.Unmarshal(jd, &md)
	if err != nil {
		return md
	}
	return md
}

func (g *AwsClient) Init(ctx context.Context) error {
	if err := g.CreateClient(ctx); err != nil {
		return err
	}
	if err := g.Validate(); err != nil {
		return err
	}
	if _, err := g.ListSecrets(ctx, ""); err != nil {
		return err
	}
	return nil
}
func (g *AwsClient) Driver() driver.DriverName {
	return driver.DriverNameAws
}
func (g *AwsClient) GetPath() string {
	return g.Name
}

func (g *AwsClient) GetSecret(ctx context.Context, name string) ([]byte, error) {
	l := log.WithFields(log.Fields{
		"action": "GetSecret",
	})
	l.Trace("start")
	defer l.Trace("end")
	arn := g.accountSecretArns[name]
	resp, err := g.client.GetSecretValue(ctx, &secretsmanager.GetSecretValueInput{
		SecretId: &arn,
	})
	if err != nil {
		l.Errorf("error: %v", err)
		return nil, err
	}
	return []byte(*resp.SecretString), nil
}

func (c *AwsClient) createSecret(ctx context.Context, name string, secret []byte) error {
	l := log.WithFields(log.Fields{
		"action": "createSecret",
		"name":   name,
		"driver": c.Driver(),
	})
	l.Trace("start")
	defer l.Trace("end")
	csi := &secretsmanager.CreateSecretInput{
		Name:         &name,
		Description:  aws.String("managed in HashiCorp Vault. do not edit directly."),
		SecretString: aws.String(string(secret)),
	}
	if c.EncryptionKey != "" {
		csi.KmsKeyId = aws.String(c.EncryptionKey)
	}
	if len(c.ReplicaRegions) > 0 {
		var rep []types.ReplicaRegionType
		for _, r := range c.ReplicaRegions {
			rr := types.ReplicaRegionType{
				Region: aws.String(r),
			}
			if c.EncryptionKey != "" {
				rr.KmsKeyId = aws.String(c.EncryptionKey)
			}
			rep = append(rep, rr)
		}
		csi.AddReplicaRegions = rep
	}
	if c.Tags != nil {
		var tags []types.Tag
		for k, v := range c.Tags {
			tags = append(tags, types.Tag{
				Key:   aws.String(k),
				Value: aws.String(v),
			})
		}
		csi.Tags = tags
	}
	_, err := c.client.CreateSecret(ctx, csi)
	if err != nil {
		l.Errorf("error: %v", err)
		return err
	}
	return nil
}

func (c *AwsClient) updateSecret(ctx context.Context, name string, secret []byte) error {
	l := log.WithFields(log.Fields{
		"action": "updateSecret",
		"name":   name,
		"driver": c.Driver(),
	})
	l.Trace("start")
	defer l.Trace("end")
	arn := c.accountSecretArns[name]
	usi := &secretsmanager.UpdateSecretInput{
		SecretId:     &arn,
		SecretString: aws.String(string(secret)),
	}
	if c.EncryptionKey != "" {
		usi.KmsKeyId = aws.String(c.EncryptionKey)
	}
	_, err := c.client.UpdateSecret(ctx, usi)
	if err != nil {
		l.Errorf("error: %v", err)
		return err
	}
	return nil
}

func (g *AwsClient) WriteSecret(ctx context.Context, meta metav1.ObjectMeta, path string, secrets []byte) ([]byte, error) {
	l := log.WithFields(log.Fields{
		"action":        "WriteSecret",
		"driver":        g.Driver(),
		"path":          path,
		"skipUnchanged": g.SkipUnchanged,
	})
	l.Trace("start")
	defer l.Trace("end")

	// Handle path conflicts: /foo vs foo
	// Check if alternate path format exists and handle it
	alternatePath := g.getAlternatePath(path)
	if alternatePath != "" {
		if _, hasAlternate := g.accountSecretArns[alternatePath]; hasAlternate {
			l.WithField("alternatePath", alternatePath).Warn("Found conflicting path format, deleting alternate")
			if err := g.DeleteSecret(ctx, alternatePath); err != nil {
				l.WithError(err).WithField("alternatePath", alternatePath).Error("Failed to delete conflicting path")
				// Continue anyway - we'll create/update the correct path
			}
		}
	}

	// If there is an existing secret, check if update is needed
	if arn, ok := g.accountSecretArns[path]; ok {
		// Idempotency: skip if value unchanged
		if g.SkipUnchanged {
			existingValue, err := g.getSecretValue(ctx, arn)
			if err != nil {
				l.WithError(err).Debug("Could not read existing secret for comparison")
			} else {
				equal, err := utils.CompareSecretsJSON(existingValue, secrets)
				if err != nil {
					l.WithError(err).Debug("Error comparing secrets")
				} else if equal {
					l.Debug("Secret unchanged, skipping update")
					return nil, nil
				}
			}
		}

		err := g.updateSecret(ctx, path, secrets)
		if err != nil {
			l.Errorf("error: %v", err)
			return nil, err
		}
	} else {
		err := g.createSecret(ctx, path, secrets)
		if err != nil {
			l.Errorf("error: %v", err)
			return nil, err
		}
	}
	return nil, nil
}

// getAlternatePath returns the alternate path format (/foo vs foo)
// Returns empty string if path is empty or contains invalid sequences
func (g *AwsClient) getAlternatePath(path string) string {
	if path == "" {
		return ""
	}
	// Validate path doesn't contain malicious sequences before processing
	// - ".." : directory traversal
	// - "\x00" : null byte injection
	// - "//" : double slashes that could cause confusion
	if strings.Contains(path, "..") || strings.Contains(path, "\x00") || strings.Contains(path, "//") {
		return "" // Invalid path, return empty to prevent processing
	}
	if strings.HasPrefix(path, "/") {
		return path[1:] // /foo -> foo
	}
	return "/" + path // foo -> /foo
}

// getSecretValue retrieves the current value of a secret by ARN
func (g *AwsClient) getSecretValue(ctx context.Context, arn string) ([]byte, error) {
	resp, err := g.client.GetSecretValue(ctx, &secretsmanager.GetSecretValueInput{
		SecretId: &arn,
	})
	if err != nil {
		return nil, err
	}
	if resp.SecretString != nil {
		return []byte(*resp.SecretString), nil
	}
	return nil, nil
}

func (g *AwsClient) DeleteSecret(ctx context.Context, secret string) error {
	l := log.WithFields(log.Fields{
		"action": "DeleteSecret",
		"driver": g.Driver(),
		"path":   secret,
	})
	l.Trace("start")
	defer l.Trace("end")
	arn := g.accountSecretArns[secret]
	_, err := g.client.DeleteSecret(ctx, &secretsmanager.DeleteSecretInput{
		SecretId: &arn,
	})
	if err != nil {
		l.Errorf("error: %v", err)
		return err
	}
	return nil
}

func (g *AwsClient) ListSecrets(ctx context.Context, p string) ([]string, error) {
	l := log.WithFields(log.Fields{
		"action":         "ListSecrets",
		"noEmptySecrets": g.NoEmptySecrets,
		"cacheTTL":       g.CacheTTL,
	})
	l.Trace("start")
	defer l.Trace("end")

	// Check cache if TTL is configured (non-zero)
	if g.CacheTTL > 0 {
		g.cacheMu.RLock()
		if time.Now().Before(g.cacheExpiry) && g.cachedSecrets != nil {
			l.Debug("Returning cached secrets list")
			cached := make([]string, len(g.cachedSecrets))
			copy(cached, g.cachedSecrets)
			g.cacheMu.RUnlock()
			return cached, nil
		}
		g.cacheMu.RUnlock()
	}

	// Cache miss or disabled - fetch from AWS
	l.Debug("Cache miss or disabled, fetching from AWS")

	// Initialize to empty slice, not nil, so callers always get a valid slice
	secretsList := []string{}
	var nextToken *string
	arnMap := make(map[string]string)
	for {
		params := &secretsmanager.ListSecretsInput{
			NextToken: nextToken,
			// Exclude secrets scheduled for deletion
			// Matches terraform-aws-secretsmanager IncludePlannedDeletion=False
			IncludePlannedDeletion: aws.Bool(false),
		}
		resp, err := g.client.ListSecrets(ctx, params)
		if err != nil {
			l.Debugf("error: %v", err)
			return nil, err
		}
		for _, secret := range resp.SecretList {
			secretName := *secret.Name

			// Skip empty secrets if configured
			// Matches terraform-aws-secretsmanager no_empty_secrets behavior
			if g.NoEmptySecrets {
				isEmpty, err := g.isSecretEmpty(ctx, *secret.ARN)
				if err != nil {
					l.WithError(err).WithField("secret", secretName).Debug("Error checking if secret is empty")
					// Include on error (fail open)
				} else if isEmpty {
					l.WithField("secret", secretName).Debug("Skipping empty secret")
					continue
				}
			}

			arnMap[secretName] = *secret.ARN
			secretsList = append(secretsList, secretName)
		}
		if resp.NextToken == nil {
			break
		}
		nextToken = resp.NextToken
	}
	g.accountSecretArns = arnMap

	// Update cache if TTL is configured
	if g.CacheTTL > 0 {
		g.cacheMu.Lock()
		g.cachedSecrets = make([]string, len(secretsList))
		copy(g.cachedSecrets, secretsList)
		g.cacheExpiry = time.Now().Add(g.CacheTTL)
		l.WithField("expiresAt", g.cacheExpiry).Debug("Updated secrets cache")
		g.cacheMu.Unlock()
	}

	return secretsList, nil
}

// isSecretEmpty checks if a secret has empty or null value
func (g *AwsClient) isSecretEmpty(ctx context.Context, arn string) (bool, error) {
	resp, err := g.client.GetSecretValue(ctx, &secretsmanager.GetSecretValueInput{
		SecretId: &arn,
	})
	if err != nil {
		return false, err
	}

	// Check for nil/empty string
	if resp.SecretString == nil || *resp.SecretString == "" {
		return true, nil
	}

	// Check for JSON null
	if *resp.SecretString == "null" {
		return true, nil
	}

	// Check for empty JSON object/array
	trimmed := strings.TrimSpace(*resp.SecretString)
	if trimmed == "{}" || trimmed == "[]" {
		return true, nil
	}

	return false, nil
}

func (c *AwsClient) SetDefaults(defaults any) error {
	dv, err := json.Marshal(defaults)
	if err != nil {
		return err
	}
	dc := &AwsClient{}
	err = json.Unmarshal(dv, dc)
	if err != nil {
		return err
	}
	if c.Region == "" && dc.Region != "" {
		c.Region = dc.Region
	}
	if c.RoleArn == "" && dc.RoleArn != "" {
		c.RoleArn = dc.RoleArn
	}
	if c.EncryptionKey == "" && dc.EncryptionKey != "" {
		c.EncryptionKey = dc.EncryptionKey
	}
	if len(c.ReplicaRegions) == 0 && len(dc.ReplicaRegions) > 0 {
		c.ReplicaRegions = dc.ReplicaRegions
	}
	// Inherit NoEmptySecrets and SkipUnchanged if not explicitly set
	// These are typically set via config, not defaults
	if dc.NoEmptySecrets {
		c.NoEmptySecrets = dc.NoEmptySecrets
	}
	if dc.SkipUnchanged {
		c.SkipUnchanged = dc.SkipUnchanged
	}
	return nil
}

// ClearCache explicitly invalidates the ListSecrets cache
// This is useful when you know secrets have been modified externally
func (c *AwsClient) ClearCache() {
	c.cacheMu.Lock()
	defer c.cacheMu.Unlock()
	c.cachedSecrets = nil
	c.cacheExpiry = time.Time{}
	log.WithField("action", "ClearCache").Debug("Cleared secrets cache")
}

func (c *AwsClient) Close() error {
	c.client = nil
	c.ClearCache()
	return nil
}
