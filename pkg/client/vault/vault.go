package vault

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"os"
	"strings"
	"time"

	reqctx "github.com/jbcom/secretsync/pkg/context"
	"github.com/jbcom/secretsync/pkg/driver"
	"github.com/jbcom/secretsync/pkg/utils"
	log "github.com/sirupsen/logrus"

	"github.com/hashicorp/vault/api"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// Vault traversal configuration defaults
const (
	// defaultMaxTraversalDepth prevents infinite loops in recursive listing
	defaultMaxTraversalDepth = 100
	// defaultMaxSecretsPerMount prevents DoS/OOM attacks from very large mounts
	defaultMaxSecretsPerMount = 100000
	// defaultQueueCompactionThreshold triggers queue memory cleanup during large traversals
	defaultQueueCompactionThreshold = 1000
)

// LogicalClient defines the interface for Vault logical operations needed for secret listing
type LogicalClient interface {
	ListWithContext(ctx context.Context, path string) (*api.Secret, error)
}

// VaultClient is a single self-contained vault client
type VaultClient struct {
	Path       string `yaml:"path,omitempty" json:"path,omitempty"`
	Address    string `yaml:"address,omitempty" json:"address,omitempty"`
	CIDR       string `yaml:"cidr,omitempty" json:"cidr,omitempty"`
	AuthMethod string `yaml:"authMethod,omitempty" json:"authMethod,omitempty"`
	Namespace  string `yaml:"namespace,omitempty" json:"namespace,omitempty"`
	TTL        string `yaml:"ttl,omitempty" json:"ttl,omitempty"`
	Merge      bool   `yaml:"merge,omitempty" json:"merge,omitempty"`

	Role string `yaml:"role,omitempty" json:"role,omitempty"`

	// Configurable traversal limits (0 = use defaults)
	MaxTraversalDepth       int `yaml:"maxTraversalDepth,omitempty" json:"maxTraversalDepth,omitempty"`
	MaxSecretsPerMount      int `yaml:"maxSecretsPerMount,omitempty" json:"maxSecretsPerMount,omitempty"`
	QueueCompactionThreshold int `yaml:"queueCompactionThreshold,omitempty" json:"queueCompactionThreshold,omitempty"`

	Client        *api.Client   `yaml:"-" json:"-"`
	logicalClient LogicalClient `yaml:"-" json:"-"` // For dependency injection in tests
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *VaultClient) DeepCopyInto(out *VaultClient) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new VaultClient.
func (in *VaultClient) DeepCopy() *VaultClient {
	if in == nil {
		return nil
	}
	out := new(VaultClient)
	in.DeepCopyInto(out)
	return out
}

func (c *VaultClient) Validate() error {
	l := log.WithFields(log.Fields{
		"action": "Validate",
	})
	l.Trace("start")
	if c.Address == "" {
		return errors.New("address required")
	}
	return nil
}

func NewClient(cfg *VaultClient) (*VaultClient, error) {
	l := log.WithFields(log.Fields{
		"action": "NewClient",
	})
	l.Trace("start")
	vc := &VaultClient{}
	jd, err := json.Marshal(cfg)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(jd, &vc)
	if err != nil {
		return nil, err
	}
	l.Tracef("client=%+v", vc)
	l.Trace("end")
	return vc, nil
}

func (vc *VaultClient) Meta() map[string]any {
	md := make(map[string]any)
	jd, err := json.Marshal(vc)
	if err != nil {
		return md
	}
	err = json.Unmarshal(jd, &md)
	if err != nil {
		return md
	}
	return md
}

func (vc *VaultClient) Driver() driver.DriverName {
	return driver.DriverNameVault
}

func (vc *VaultClient) GetPath() string {
	return vc.Path
}

// NewClients creates and returns a new vault client with a valid token or error
func (vc *VaultClient) NewClient(ctx context.Context) (*api.Client, error) {
	log.Tracef("vault.NewClient")
	config := &api.Config{
		Address: vc.Address,
		Timeout: 30 * time.Second, // Prevent hung connections
	}
	var err error
	vc.Client, err = api.NewClient(config)
	if err != nil {
		return vc.Client, err
	}
	if vc.Namespace != "" {
		vc.Client.SetNamespace(vc.Namespace)
	}
	terr := vc.NewToken(ctx)
	if terr != nil {
		return vc.Client, terr
	}
	vc.Client.AddHeader("x-vault-sync", "true")
	return vc.Client, err
}

// Login creates a vault token with the k8s auth provider
func (vc *VaultClient) Login(ctx context.Context) error {
	l := log.WithFields(log.Fields{
		"address":   vc.Address,
		"role":      vc.Role,
		"path":      vc.Path,
		"method":    vc.AuthMethod,
		"namespace": vc.Namespace,
	})
	l.Trace("vault.Login")
	if vc.Client == nil {
		_, err := vc.NewClient(ctx)
		if err != nil {
			return err
		}
	}
	var kubeTokenExists bool
	ktp := "/var/run/secrets/kubernetes.io/serviceaccount/token"
	if _, err := os.Stat(ktp); !os.IsNotExist(err) {
		l.Tracef("kubeToken exists at path=%s", ktp)
		kubeTokenExists = true
	}
	var kt string
	if kubeTokenExists {
		l.Tracef("reading kubeToken from path=%s", ktp)
		fd, err := os.ReadFile(ktp)
		if err != nil {
			return err
		}
		kt = string(fd)
	}
	if kt != "" {
		options := map[string]interface{}{
			"role": vc.Role,
			"jwt":  kt,
		}
		if vc.TTL != "" {
			options["ttl"] = vc.TTL
		}
		path := fmt.Sprintf("auth/%s/login", vc.AuthMethod)
		l.WithFields(log.Fields{
			"path": path,
			"role": vc.Role,
		}).Trace("vault.Login calling Write")
		secret, err := vc.Client.Logical().WriteWithContext(ctx, path, options)
		if err != nil {
			return err
		}
		vc.Client.SetToken(secret.Auth.ClientToken)
	} else {
		vc.Client.SetToken(os.Getenv("VAULT_TOKEN"))
	}
	return nil
}

func (vc *VaultClient) Init(ctx context.Context) error {
	if err := vc.NewToken(ctx); err != nil {
		return err
	}
	if err := vc.Validate(); err != nil {
		return err
	}
	return nil
}

func (vc *VaultClient) NewToken(ctx context.Context) error {
	l := log.WithFields(log.Fields{
		"address": vc.Address,
		"role":    vc.Role,
		"path":    vc.Path,
		"method":  vc.AuthMethod,
	})
	l.Trace("vault.NewToken calling Login")
	if os.Getenv("VAULT_TOKEN") != "" {
		l.Trace("using VAULT_TOKEN")
		if vc.Client == nil {
			_, err := vc.NewClient(ctx)
			if err != nil {
				return err
			}
		}
		vc.Client.SetToken(os.Getenv("VAULT_TOKEN"))
	}
	if err := vc.Login(ctx); err != nil {
		return err
	}
	return nil
}

func insertSliceString(a []string, index int, value string) []string {
	if len(a) == index { // nil or empty slice or after last element
		return append(a, value)
	}
	a = append(a[:index+1], a[index:]...) // index < len(a)
	a[index] = value
	return a
}

// GetKVSecret retrieves a kv secret from vault
func (vc *VaultClient) GetKVSecretOnce(ctx context.Context, s string) (map[string]interface{}, error) {
	requestID := reqctx.GetRequestID(ctx)
	l := log.WithFields(log.Fields{
		"action":     "GetKVSecretOnce",
		"address":    vc.Address,
		"role":       vc.Role,
		"path":       s,
		"method":     vc.AuthMethod,
		"request_id": requestID,
	})
	errBuilder := reqctx.NewErrorBuilder(ctx, "vault.read").WithPath(s)
	
	var secrets map[string]interface{}
	if s == "" {
		return secrets, errBuilder.Build("secret path required", nil)
	}
	ss := strings.Split(s, "/")
	if len(ss) < 2 {
		return secrets, errBuilder.Build("secret path must be in kv/path/to/secret format", nil)
	}
	ss = insertSliceString(ss, 1, "data")
	//log.Debugf("headers_sent=%+v", vc.Client.Headers())
	c := vc.Client.Logical()
	s = strings.Join(ss, "/")
	if c == nil {
		return secrets, errBuilder.Build("vault client not initialized", nil)
	}
	secret, err := c.ReadWithContext(ctx, s)
	if err != nil {
		return secrets, errBuilder.Wrap(err, "failed to read secret")
	}
	if secret == nil || secret.Data == nil {
		return nil, errBuilder.Build("secret not found", nil)
	}
	l.Tracef("secret=%+v", secret)
	if secret.Data["data"] == nil {
		return nil, errBuilder.Build("secret data not found", nil)
	}

	// Type-safe extraction to prevent runtime panics
	data, ok := secret.Data["data"].(map[string]interface{})
	if !ok {
		return nil, errBuilder.Errorf("unexpected data type in Vault response: got %T, expected map[string]interface{}", secret.Data["data"])
	}
	return data, nil
}

// GetKVSecret will login and retry secret access on failure
// to gracefully handle token expiration
func (vc *VaultClient) GetSecret(ctx context.Context, s string) ([]byte, error) {
	var sec map[string]interface{}
	var err error
	terr := vc.NewToken(ctx)
	if terr != nil {
		return nil, terr
	}
	sec, err = vc.GetKVSecretOnce(ctx, s)
	if err != nil {
		terr := vc.NewToken(ctx)
		if terr != nil {
			return nil, terr
		}
		sec, err = vc.GetKVSecretOnce(ctx, s)
		if err != nil {
			return nil, err
		}
	}
	b, err := json.Marshal(sec)
	if err != nil {
		return nil, err
	}
	return b, err
}

// WriteSecret will login and retry secret write on failure
// to gracefully handle token expiration.
//
// When Merge is true, uses deepmerge semantics matching the original
// terraform-aws-secretsmanager pipeline:
//   - Lists: APPEND (src items appended to dst)
//   - Dicts: MERGE (recursive deep merge)
//   - Scalars: OVERRIDE (later value wins)
//   - Type conflicts: OVERRIDE (later value wins)
func (vc *VaultClient) WriteSecret(ctx context.Context, meta metav1.ObjectMeta, s string, bData []byte) ([]byte, error) {
	l := log.WithFields(log.Fields{
		"address": vc.Address,
		"role":    vc.Role,
		"path":    s,
		"method":  vc.AuthMethod,
		"merge":   vc.Merge,
	})
	var data map[string]interface{}
	err := json.Unmarshal(bData, &data)
	if err != nil {
		return nil, err
	}
	var secrets map[string]interface{}
	if vc.Merge {
		sec, getErr := vc.GetSecret(ctx, s)
		if getErr != nil {
			// Distinguish between "secret doesn't exist" (404) vs actual errors
			var respErr *api.ResponseError
			if errors.As(getErr, &respErr) && respErr.StatusCode == 404 {
				// Secret doesn't exist yet, that's fine for merge - we'll create it
				l.WithError(getErr).Debug("no existing secret to merge with, creating new")
			} else {
				// Network, authentication, or other errors should fail the operation
				return nil, fmt.Errorf("failed to check for existing secret during merge: %w", getErr)
			}
		} else {
			var existingData map[string]interface{}
			unmarshalErr := json.Unmarshal(sec, &existingData)
			if unmarshalErr != nil {
				l.WithError(unmarshalErr).Warn("failed to parse existing secret as JSON, will override")
			} else {
				// Use proper deepmerge: existing + new data
				// This matches Python deepmerge.Merger behavior:
				// - Lists: append
				// - Dicts: recursive merge
				// - Scalars/conflicts: override
				data = utils.DeepMerge(existingData, data)
				l.Debug("applied deepmerge to existing secret")
			}
		}
	}
	terr := vc.NewToken(ctx)
	if terr != nil {
		return nil, terr
	}
	secrets, err = vc.WriteSecretWithLatestCAS(ctx, s, data)
	if err != nil {
		terr := vc.NewToken(ctx)
		if terr != nil {
			return nil, terr
		}
		secrets, err = vc.WriteSecretWithLatestCAS(ctx, s, data)
		if err != nil {
			return nil, err
		}
	}
	l.Tracef("secrets=%+v", secrets)
	return nil, err
}

// WriteSecret writes a secret to Vault VaultClient at path p with secret value s
func (vc *VaultClient) WriteSecretOnce(ctx context.Context, p string, s map[string]interface{}, cas *int) (map[string]interface{}, error) {
	errBuilder := reqctx.NewErrorBuilder(ctx, "vault.write").WithPath(p)
	
	var secrets map[string]interface{}
	pp := strings.Split(p, "/")
	if len(pp) < 2 {
		return secrets, errBuilder.Build("secret path must be in kv/path/to/secret format", nil)
	}
	pp = insertSliceString(pp, 1, "data")
	p = strings.Join(pp, "/")
	if s == nil {
		return secrets, errBuilder.Build("secret data required", nil)
	}
	if p == "" {
		return secrets, errBuilder.Build("secret path required", nil)
	}

	// Prepare the data payload
	vd := map[string]interface{}{
		"data": s,
	}

	// Add CAS parameter if provided
	if cas != nil {
		vd["options"] = map[string]interface{}{
			"cas": *cas,
		}
	}

	_, err := vc.Client.Logical().WriteWithContext(ctx, p, vd)
	if err != nil {
		return secrets, errBuilder.Wrap(err, "failed to write secret")
	}
	return secrets, nil
}

func (vc *VaultClient) WriteSecretWithLatestCAS(ctx context.Context, p string, s map[string]interface{}) (map[string]interface{}, error) {
	var secrets map[string]interface{}
	originalPath := p

	// Validate path
	pp := strings.Split(p, "/")
	if len(pp) < 2 {
		return secrets, errors.New("secret path must be in kv/path/to/secret format")
	}

	// Get the current version from metadata
	metadataPath := make([]string, len(pp))
	copy(metadataPath, pp)
	metadataPath = insertSliceString(metadataPath, 1, "metadata")
	metadataPathStr := strings.Join(metadataPath, "/")

	metadata, err := vc.Client.Logical().ReadWithContext(ctx, metadataPathStr)

	// Prepare the cas value
	var cas *int = nil

	// If metadata exists and has a current_version field
	if err == nil && metadata != nil && metadata.Data != nil {
		if cv, ok := metadata.Data["current_version"]; ok {
			// Handle different possible types
			switch v := cv.(type) {
			case json.Number:
				if intVal, err := v.Int64(); err == nil {
					intCas := int(intVal)
					cas = &intCas
				}
			case float64:
				intCas := int(v)
				cas = &intCas
			case int:
				cas = &v
			case int64:
				intCas := int(v)
				cas = &intCas
			}
		}
	}

	// Use the WriteSecretOnce function with the cas value
	return vc.WriteSecretOnce(ctx, originalPath, s, cas)
}

// DeleteSecret deletes a secret from path p
func (vc *VaultClient) DeleteSecret(ctx context.Context, p string) error {
	l := log.WithFields(log.Fields{
		"address": vc.Address,
		"role":    vc.Role,
		"path":    p,
		"method":  vc.AuthMethod,
	})
	if p == "" {
		return errors.New("secret path required")
	}
	pp := strings.Split(p, "/")
	if len(pp) < 2 {
		return errors.New("secret path must be in kv/path/to/secret format")
	}
	if !strings.Contains(p, "/metadata/") {
		pp = insertSliceString(pp, 1, "metadata")
		p = strings.Join(pp, "/")
	}
	terr := vc.NewToken(ctx)
	if terr != nil {
		return terr
	}
	_, err := vc.Client.Logical().DeleteWithContext(ctx, p)
	if err != nil {
		l.WithFields(log.Fields{
			"error": err,
		}).Error("vault.DeleteSecret")
		return err
	}
	l.Debug("secret deleted")
	return nil
}

// getMaxTraversalDepth returns the configured max depth or the default
func (vc *VaultClient) getMaxTraversalDepth() int {
	if vc.MaxTraversalDepth > 0 {
		return vc.MaxTraversalDepth
	}
	return defaultMaxTraversalDepth
}

// getMaxSecretsPerMount returns the configured max secrets or the default
func (vc *VaultClient) getMaxSecretsPerMount() int {
	if vc.MaxSecretsPerMount > 0 {
		return vc.MaxSecretsPerMount
	}
	return defaultMaxSecretsPerMount
}

// getQueueCompactionThreshold returns the configured threshold or the default
func (vc *VaultClient) getQueueCompactionThreshold() int {
	if vc.QueueCompactionThreshold > 0 {
		return vc.QueueCompactionThreshold
	}
	return defaultQueueCompactionThreshold
}

func (vc *VaultClient) ListSecretsOnce(ctx context.Context, p string) ([]string, error) {
	errBuilder := reqctx.NewErrorBuilder(ctx, "vault.list").WithPath(p)
	
	if vc == nil || vc.Client == nil {
		return nil, errBuilder.Build("vault client not initialized", nil)
	}
	if p == "" {
		return nil, errBuilder.Build("secret path required", nil)
	}
	pp := strings.Split(p, "/")
	if len(pp) < 2 {
		return nil, errBuilder.Build("secret path must be in kv/path/to/secret format", nil)
	}

	// Use BFS to recursively discover all secrets
	return vc.listSecretsRecursive(ctx, p)
}

// listSecretsRecursive performs breadth-first search to discover all nested secrets
func (vc *VaultClient) listSecretsRecursive(ctx context.Context, basePath string) ([]string, error) {
	requestID := reqctx.GetRequestID(ctx)
	l := log.WithFields(log.Fields{
		"action":     "listSecretsRecursive",
		"address":    vc.Address,
		"role":       vc.Role,
		"path":       basePath,
		"method":     vc.AuthMethod,
		"request_id": requestID,
	})
	l.Info("Starting recursive secret listing with BFS traversal")
	
	errBuilder := reqctx.NewErrorBuilder(ctx, "vault.list_recursive").WithPath(basePath)

	var allSecrets []string
	visited := make(map[string]bool)

	// Normalize basePath to prevent double-slash issues
	basePath = strings.TrimSuffix(basePath, "/")

	// Get configured limits
	maxDepth := vc.getMaxTraversalDepth()
	maxSecrets := vc.getMaxSecretsPerMount()
	compactionThreshold := vc.getQueueCompactionThreshold()

	// Use index-based queue to avoid O(nÂ²) slice reallocation on dequeue
	// Instead of queue = queue[1:] which allocates on each dequeue,
	// we advance an index and let GC handle the old references
	queue := []string{basePath}
	queueIdx := 0

	for queueIdx < len(queue) {
		// Check for context cancellation
		select {
		case <-ctx.Done():
			return nil, errBuilder.Wrap(ctx.Err(), "operation cancelled")
		default:
		}

		currentPath := queue[queueIdx]
		queueIdx++

		// Periodically compact queue to free memory on very large traversals
		if queueIdx > compactionThreshold && queueIdx > len(queue)/2 {
			queue = queue[queueIdx:]
			queueIdx = 0
		}

		// Skip if already visited to prevent infinite loops
		if visited[currentPath] {
			continue
		}
		visited[currentPath] = true

		// Check depth limit as safety measure
		depth := strings.Count(strings.TrimPrefix(currentPath, basePath), "/")
		if depth > maxDepth {
			return nil, errBuilder.Errorf("max traversal depth %d exceeded at path %q (base: %q, found %d secrets so far)",
				maxDepth, currentPath, basePath, len(allSecrets))
		}

		// Get the metadata path for listing
		metadataPath, err := vc.getMetadataPath(currentPath)
		if err != nil {
			l.WithError(err).Warnf("failed to get metadata path for %s", currentPath)
			continue
		}

		// List contents at current path
		keys, err := vc.listPathContents(ctx, metadataPath)
		if err != nil {
			// Use typed error checking instead of brittle string matching
			var respErr *api.ResponseError
			if errors.As(err, &respErr) {
				// 403 (Forbidden) and 404 (Not Found) are expected for inaccessible paths
				if respErr.StatusCode == 403 || respErr.StatusCode == 404 {
					l.WithError(err).Debugf("Skipping inaccessible path (HTTP %d): %s", respErr.StatusCode, metadataPath)
					continue
				}
			}
			// Network, authentication, or other critical errors should propagate
			return nil, reqctx.NewErrorBuilder(ctx, "vault.list_path").
				WithPath(metadataPath).
				Wrap(err, fmt.Sprintf("failed to list path at depth %d (%d secrets found so far)", depth, len(allSecrets)))
		}

		if keys == nil {
			continue
		}

		// Process each key found
		for _, key := range keys {
			// Validate key doesn't contain path traversal or malicious sequences:
			// - ".." : directory traversal
			// - "\x00" : null byte injection
			// - "//" : double slashes that could cause path confusion
			// - leading "/" : absolute path that could escape context
			if strings.Contains(key, "..") || strings.Contains(key, "\x00") ||
				strings.Contains(key, "//") || strings.HasPrefix(key, "/") {
				l.Warnf("skipping key with invalid path characters: %s", key)
				continue
			}

			// Construct the full path maintaining original format
			var fullPath string
			if strings.HasSuffix(currentPath, "/") {
				fullPath = currentPath + key
			} else {
				fullPath = currentPath + "/" + key
			}

			if strings.HasSuffix(key, "/") {
				// It's a directory - add to queue for recursive exploration
				// Remove trailing slash for consistent path handling
				dirPath := strings.TrimSuffix(fullPath, "/")
				if !visited[dirPath] {
					queue = append(queue, dirPath)
				}
			} else {
				// It's a secret - add to results
				allSecrets = append(allSecrets, fullPath)
				// Check if we've exceeded the maximum secrets limit to prevent DoS/OOM
				if len(allSecrets) > maxSecrets {
					return nil, errBuilder.Errorf("mount %q contains more than %d secrets at depth %d (possible DoS attack or misconfiguration)",
						basePath, maxSecrets, depth)
				}
			}
		}
	}

	l.WithFields(log.Fields{
		"request_id":  requestID,
		"secretCount": len(allSecrets),
		"duration_ms": reqctx.GetElapsedTime(ctx).Milliseconds(),
	}).Info("Completed recursive secret listing")

	return allSecrets, nil
}

// getMetadataPath converts a KV path to its metadata equivalent
func (vc *VaultClient) getMetadataPath(path string) (string, error) {
	// Validate path BEFORE any manipulation to prevent path traversal attacks
	if strings.Contains(path, "..") || strings.Contains(path, "\x00") ||
		strings.Contains(path, "//") || strings.HasPrefix(path, "/") {
		return "", fmt.Errorf("invalid path: contains forbidden characters")
	}

	// Normalize path by trimming trailing slashes to prevent empty segments
	path = strings.TrimSuffix(path, "/")
	pp := strings.Split(path, "/")
	if len(pp) < 2 {
		return "", errors.New("secret path must be in kv/path/to/secret format")
	}
	pp = insertSliceString(pp, 1, "metadata")
	metadataPath := strings.Join(pp, "/")
	if !strings.HasSuffix(metadataPath, "/") {
		metadataPath = metadataPath + "/"
	}
	return metadataPath, nil
}

// SetLogicalClient sets a mock logical client for testing
func (vc *VaultClient) SetLogicalClient(client LogicalClient) {
	vc.logicalClient = client
}

// getLogicalClient returns the injected mock client or the real client
func (vc *VaultClient) getLogicalClient() LogicalClient {
	if vc.logicalClient != nil {
		return vc.logicalClient
	}
	if vc.Client == nil {
		return nil
	}
	return vc.Client.Logical()
}

// listPathContents performs the actual Vault LIST operation
func (vc *VaultClient) listPathContents(ctx context.Context, metadataPath string) ([]string, error) {
	logical := vc.getLogicalClient()
	if logical == nil {
		return nil, errors.New("vault client not initialized")
	}
	secret, err := logical.ListWithContext(ctx, metadataPath)
	if err != nil {
		return nil, err
	}
	if secret == nil {
		return nil, nil
	}
	if secret.Data == nil || secret.Data["keys"] == nil {
		return nil, nil
	}
	
	// Type-safe extraction of keys
	keysInterface, ok := secret.Data["keys"].([]interface{})
	if !ok {
		return nil, fmt.Errorf("unexpected keys type in Vault response: %T", secret.Data["keys"])
	}
	
	var keys []string
	for i, v := range keysInterface {
		keyStr, ok := v.(string)
		if !ok {
			return nil, fmt.Errorf("unexpected key type at index %d: %T", i, v)
		}
		keys = append(keys, keyStr)
	}
	return keys, nil
}

func (vc *VaultClient) ListSecrets(ctx context.Context, p string) ([]string, error) {
	var keys []string
	var err error
	terr := vc.NewToken(ctx)
	if terr != nil {
		return keys, terr
	}
	keys, err = vc.ListSecretsOnce(ctx, p)
	if err != nil {
		terr := vc.NewToken(ctx)
		if terr != nil {
			return keys, terr
		}
		keys, err = vc.ListSecretsOnce(ctx, p)
		if err != nil {
			return keys, err
		}
	}
	return keys, err
}

func (c *VaultClient) Close() error {
	c.Client.ClearToken()
	return nil
}

func (c *VaultClient) SetDefaults(defaults any) error {
	dv, err := json.Marshal(defaults)
	if err != nil {
		return err
	}
	dc := &VaultClient{}
	err = json.Unmarshal(dv, dc)
	if err != nil {
		return err
	}
	if c.Address == "" && dc.Address != "" {
		c.Address = dc.Address
	}
	if c.CIDR == "" && dc.CIDR != "" {
		c.CIDR = dc.CIDR
	}
	if c.AuthMethod == "" && dc.AuthMethod != "" {
		c.AuthMethod = dc.AuthMethod
	}
	if c.Namespace == "" && dc.Namespace != "" {
		c.Namespace = dc.Namespace
	}
	if c.Role == "" && dc.Role != "" {
		c.Role = dc.Role
	}
	if c.TTL == "" && dc.TTL != "" {
		c.TTL = dc.TTL
	}
	return nil
}
