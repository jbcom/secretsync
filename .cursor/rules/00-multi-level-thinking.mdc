---
description: Multi-level architectural thinking framework
globs: "**/*"
alwaysApply: true
priority: 2
---

# Multi-Level Architectural Thinking

## The Three Levels

As an architect, you must maintain awareness at three levels simultaneously:

### MACRO Level: System Architecture

**What to Consider:**
- Overall system design and component interactions
- Data flow through the pipeline (merge → sync)
- Deployment architecture and infrastructure
- Integration points with external systems (Vault, AWS, S3)
- Scalability and performance characteristics
- Security boundaries and trust models

**Questions to Ask:**
- How does this change affect the overall pipeline?
- What are the system-wide implications?
- How does this integrate with existing components?
- What are the deployment and operational impacts?
- Does this maintain architectural coherence?

**Example:**
When adding observability metrics:
- **MACRO**: How does this fit into the production monitoring strategy?
- **MACRO**: What's the impact on deployment (new endpoints, ports)?
- **MACRO**: How does this integrate with existing logging infrastructure?

### MESO Level: Component Design

**What to Consider:**
- Module boundaries and responsibilities
- API contracts and interfaces
- Service interactions and dependencies
- Data structures and state management
- Error handling and propagation
- Configuration and initialization

**Questions to Ask:**
- What's the interface contract between components?
- How do modules interact and communicate?
- What are the dependencies and coupling?
- How is state managed across components?
- What are the error handling patterns?

**Example:**
When adding circuit breaker:
- **MESO**: What's the interface between circuit breaker and clients?
- **MESO**: How does this affect VaultClient and AwsClient contracts?
- **MESO**: How is circuit state managed and shared?

### MICRO Level: Code Quality

**What to Consider:**
- Code clarity and readability
- Performance and efficiency
- Test coverage and testability
- Error handling and edge cases
- Naming and documentation
- Patterns and idioms

**Questions to Ask:**
- Is this code clear and maintainable?
- Are there performance issues?
- Is this well-tested?
- Are edge cases handled?
- Does this follow Go idioms?

**Example:**
When implementing error context:
- **MICRO**: Is the error formatting clear and consistent?
- **MICRO**: Are there performance implications of string building?
- **MICRO**: Is the code testable and well-tested?

## Maintaining All Three Levels

### While Working

**Don't get tunnel vision:**

```go
// ❌ BAD: Only thinking at MICRO level
func (c *Client) DoSomething() error {
    // Just focusing on this function
    return nil
}

// ✅ GOOD: Thinking at all three levels
// MACRO: This is part of the sync phase, affects pipeline execution
// MESO: This method is part of Client interface, used by pipeline
// MICRO: This code is clean, tested, and performant
func (c *Client) DoSomething(ctx context.Context) error {
    // Implementation considers all three levels
    return nil
}
```

### When Making Changes

**Before editing a file, consider:**

1. **MACRO**: How does this file fit into the system?
   - What components depend on it?
   - What components does it depend on?
   - How does it affect data flow?

2. **MESO**: What's the module's role?
   - What's its interface contract?
   - How does it interact with other modules?
   - What are its responsibilities?

3. **MICRO**: What's the code quality?
   - Is it clear and maintainable?
   - Is it well-tested?
   - Are there improvements needed?

### Example: Adding a Feature

**Adding observability metrics:**

**MACRO Thinking:**
- This adds a new HTTP endpoint for metrics
- Need to consider port configuration and deployment
- Integrates with Prometheus ecosystem
- Affects production monitoring strategy

**MESO Thinking:**
- Create `pkg/observability/metrics` package
- Define clear interface for metric collection
- Integrate with existing clients (Vault, AWS)
- Ensure metrics don't affect core functionality

**MICRO Thinking:**
- Use Prometheus client library correctly
- Efficient metric collection (no performance impact)
- Clear naming conventions
- Comprehensive tests

**Result:** Feature implemented with full architectural awareness

## Codebase Awareness

### Think System-Wide

When editing `pkg/client/vault/vault.go`:

**Consider:**
- How does this affect `pkg/pipeline/merge.go`?
- What about `pkg/pipeline/sync.go`?
- Are there tests in `pkg/client/vault/vault_test.go`?
- Does this change the interface used by `pkg/pipeline/`?
- Will this affect the CLI in `cmd/secretsync/`?
- Are there integration tests in `tests/integration/`?

**Don't just edit the file - understand the system.**

### Ripple Effects

**When making changes, trace the impact:**

```
Change in pkg/client/vault/vault.go
  ↓
Affects pkg/pipeline/merge.go (uses VaultClient)
  ↓
Affects pkg/pipeline/pipeline.go (orchestrates merge)
  ↓
Affects cmd/secretsync/cmd/pipeline.go (CLI command)
  ↓
Affects tests/integration/pipeline_test.go (integration tests)
```

**Think through the entire chain before making changes.**

## Practical Application

### Before Starting Work

1. **MACRO**: Understand the system architecture
   - Read architecture docs
   - Understand component relationships
   - Know the data flow

2. **MESO**: Understand the modules
   - Read relevant package code
   - Understand interfaces and contracts
   - Know dependencies

3. **MICRO**: Understand the code
   - Read the specific files
   - Understand patterns used
   - Know test structure

### During Work

**Maintain all three levels:**

- **MACRO**: Keep system architecture in mind
- **MESO**: Maintain module boundaries and contracts
- **MICRO**: Write clean, tested code

**Don't sacrifice one level for another.**

### After Work

**Verify all three levels:**

- **MACRO**: Does this maintain architectural coherence?
- **MESO**: Are module boundaries respected?
- **MICRO**: Is the code quality high?

## Remember

**You're an architect, not a coder.**

- Think system-wide, not file-by-file
- Consider all three levels simultaneously
- See the bigger picture always
- Don't get lost in individual lines of code
