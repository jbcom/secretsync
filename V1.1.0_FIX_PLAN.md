# v1.1.0 Fix Plan - URGENT

## Status: v1.1.0 Released with BROKEN CI

**Date:** December 9, 2025  
**Priority:** P0 - CRITICAL  
**Estimated Time:** 4-6 hours

---

## Critical Lint Errors (BLOCKING ALL MERGES)

### Error 1: copylocks in VaultClient.DeepCopyInto()

**File:** `pkg/client/vault/vault.go:63`  
**Error:**
```
copylocks: assignment copies lock value to *out: 
github.com/jbcom/secretsync/pkg/client/vault.VaultClient contains 
sync.Once contains sync.noCopy (govet)
```

**Root Cause:**  
The `VaultClient` struct contains `breakerOnce sync.Once` which has an embedded lock (`sync.noCopy`). The current `DeepCopyInto` implementation correctly handles this by creating a new `sync.Once{}`, but there might be an issue with how the struct is being copied.

**Current Code (lines 61-84):**
```go
func (in *VaultClient) DeepCopyInto(out *VaultClient) {
	if in == nil || out == nil {
		return
	}

	out.Path = in.Path
	out.Address = in.Address
	out.CIDR = in.CIDR
	out.AuthMethod = in.AuthMethod
	out.Namespace = in.Namespace
	out.TTL = in.TTL
	out.Merge = in.Merge
	out.Role = in.Role
	out.MaxTraversalDepth = in.MaxTraversalDepth
	out.MaxSecretsPerMount = in.MaxSecretsPerMount
	out.QueueCompactionThreshold = in.QueueCompactionThreshold

	// Pointers/interfaces copied as-is; breakerOnce intentionally zeroed to avoid copying locks
	out.Client = in.Client
	out.logicalClient = in.logicalClient
	out.breaker = in.breaker
	out.breakerOnce = sync.Once{}
}
```

**Fix:** The code looks correct, but golangci-lint v2.7.2 might be detecting something. Need to verify the exact line and potentially restructure.

**Action Items:**
1. Run `golangci-lint run --no-config pkg/client/vault/vault.go` to see exact error
2. If needed, restructure DeepCopyInto to avoid any struct assignment
3. Verify fix with `golangci-lint run`

---

### Error 2: staticcheck QF1003 in CircuitBreaker

**File:** `pkg/circuitbreaker/circuitbreaker.go:142`  
**Error:**
```
QF1003: could use tagged switch on err (staticcheck)
if err == gobreaker.ErrOpenState {
```

**Root Cause:**  
Staticcheck suggests using a type switch instead of if-else chain for error checking.

**Current Code (lines 140-150 approx):**
```go
func (cb *CircuitBreaker) WrapError(err error) error {
	if err == nil {
		return nil
	}
	if err == gobreaker.ErrOpenState {
		return ErrCircuitOpen
	}
	if err == gobreaker.ErrTooManyRequests {
		return ErrTooManyRequests
	}
	return err
}
```

**Fix:**
```go
func (cb *CircuitBreaker) WrapError(err error) error {
	if err == nil {
		return nil
	}
	switch err {
	case gobreaker.ErrOpenState:
		return ErrCircuitOpen
	case gobreaker.ErrTooManyRequests:
		return ErrTooManyRequests
	default:
		return err
	}
}
```

**Action Items:**
1. Replace if-else chain with switch statement
2. Verify fix with `golangci-lint run`

---

## Verification Checklist

After fixes are applied, run the following in order:

### 1. Local Verification
```bash
# Fix lint errors
golangci-lint run

# Run all tests
go test ./... -v

# Run with race detector
go test ./... -race

# Build binary
go build ./...

# Run integration tests
docker-compose -f docker-compose.test.yml up --abort-on-container-exit
```

### 2. Create Fix PR
```bash
# Create branch
git checkout -b fix/v1.1.0-lint-errors

# Make fixes
# ... edit files ...

# Commit
git add .
git commit -m "fix(lint): resolve copylocks and staticcheck errors

- Fix VaultClient.DeepCopyInto() copylocks issue
- Replace if-else with switch in CircuitBreaker.WrapError()
- Verified with golangci-lint v2.7.2

Fixes #75"

# Push
git push origin fix/v1.1.0-lint-errors

# Create PR
gh pr create --title "fix(lint): resolve v1.1.0 lint errors" \
  --body "Fixes critical lint errors blocking CI

## Changes
- Fix copylocks in VaultClient.DeepCopyInto()
- Fix staticcheck QF1003 in CircuitBreaker.WrapError()

## Verification
- ✅ golangci-lint run passes
- ✅ go test ./... passes
- ✅ go test -race ./... passes
- ✅ Integration tests pass

Closes #75"
```

### 3. Verify CI Passes
- Wait for CI to complete
- Verify all checks green
- Merge to main

### 4. Verify Main Branch
```bash
# After merge
git checkout main
git pull

# Verify everything still works
golangci-lint run
go test ./... -race
```

---

## Post-Fix Actions

### 1. Update Assessment Document
Update `CODEBASE_ASSESSMENT.md` with:
- ✅ Lint errors fixed
- ✅ CI passing
- Current status of all v1.1.0 features

### 2. Close/Update Issues
- Close #75 (lint fix PR)
- Update #60 (v1.1.0 EPIC) with current status
- Verify which issues should actually be closed

### 3. Update Requirements Document
Based on assessment, update `.kiro/specs/secretsync-complete/requirements.md` to reflect:
- What's actually complete in v1.1.0
- What's partial/incomplete
- What needs to be done for v1.2.0

---

## Timeline

**Hour 1:** Fix lint errors
- Fix copylocks issue
- Fix staticcheck issue
- Local verification

**Hour 2:** Testing
- Run full test suite
- Run integration tests
- Verify race detector

**Hour 3:** PR and CI
- Create PR
- Wait for CI
- Address any issues

**Hour 4:** Merge and verify
- Merge PR
- Verify main branch
- Update documentation

**Hours 5-6:** Assessment and cleanup
- Update CODEBASE_ASSESSMENT.md
- Close/update issues
- Update requirements document

---

## Success Criteria

Before considering v1.1.0 "fixed":
- [ ] All lint errors resolved
- [ ] CI passing on main
- [ ] All tests passing (unit + integration)
- [ ] Race detector clean
- [ ] Documentation updated
- [ ] Issues properly closed/updated
- [ ] Requirements document reflects reality

---

## Lessons Learned (For Future)

**What Went Wrong:**
1. Code merged without passing lint
2. Issues closed without verification
3. Features claimed complete but not fully integrated
4. No integration tests in CI

**Preventive Measures:**
1. Make lint a required CI check (already is, but was bypassed)
2. Never close issues without manual verification
3. Add integration tests to CI workflow
4. Require manual smoke test before release
5. Use this fix plan as template for future releases

---

**Plan Created:** December 9, 2025  
**Owner:** Kiro AI Agent  
**Status:** READY TO EXECUTE
